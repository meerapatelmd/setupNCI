#' @title
#' Process NCI Thesaurus OWL into OMOP Tables
#'
#' @return
#' CSV files
#'
#' @details
#' The OWL files are first processed into the Neo4j nodes and edges csvs
#' using the `process_owl_to_neo4j` function in this package. These csvs are then
#' processed further into OMOP format Vocabulary table csvs: CONCEPT, CONCEPT_SYNONYM,
#' CONCEPT_RELATIONSHIP, CONCEPT_ANCESTOR. Metadata tables VOCABULARY, RELATIONSHIP,
#' and CONCEPT_CLASS are also created.
#'
#' CONCEPT:
#' Concept ids are generated by row number + 20000. Concept ids are not created for
#' any of the metadata concepts in the VOCABULARY, RELATIONSHIP and CONCEPT_CLASS tables.
#' The `domain_id` is determined by the source `rel_type` value in the Edges file. The
#' `concept_class_id` are dependant on the placement of the hierarchy. If it is
#' the topmost ancestor, it is 'Root' Class. If it is a bottomost descendant, it is
#' a 'Leaf' Non-Standard Concept. Otherwise the concept is a 'SubClass' Non-Standard Concept.
#' If there is any value found within the `Concept_Status` field in the nodes csv,
#' the concept is deprecated in the final concept table.
#'
#' CONCEPT_RELATIONSHIP:
#' All relationships (asserted, inherited, and annotation) are used to generate these csvs.
#' The exact `rel_type` from the source edge csv is lost in this processing.
#'
#' CONCEPT_SYNONYM: All language concepts id are 4180186, only
#' concept synonyms in the `FULL_SYN` source field that did not have a
#' lowercased match to the `Preferred_Name` was used.
#'
#' @rdname process_owl_to_omop
#'
#'
#' @export
#' @import tidyverse

process_owl_to_omop <-
  function(nci_version) {
    vocabulary_id <- "CAI NCIt"
    vocabulary_name <- "CAI NCI Thesaurus"
    vocabulary_version <- nci_version

    pkg_options(output_folder = file.path(here::here(), "inst", "data"))

    output_folder <-
      pkg_options("output_folder")

    owl_folder <-
      file.path(
        output_folder,
        "owl"
      )


    neo4j_folder <-
      file.path(
        output_folder,
        "neo4j",
        nci_version
      )


    omop_folder <-
      file.path(
        output_folder,
        "omop",
        nci_version
      )

    omop_folder <-
      makedirs(
        folder_path = omop_folder,
        verbose = FALSE
      )

    final_files <-
      c(
        "CONCEPT_ANCESTOR.csv",
        "CONCEPT_CLASS.csv",
        "CONCEPT_RELATIONSHIP.csv",
        "CONCEPT_SYNONYM.csv",
        "CONCEPT.csv",
        "RELATIONSHIP.csv",
        "VOCABULARY.csv"
      )
    final_paths <-
      file.path(
        omop_folder,
        final_files
      )


    if (any(!file.exists(final_paths))) {
      process_owl_to_neo4j(
        nci_version = nci_version
      )


      node <-
        readr::read_csv(
          file =
            file.path(
              neo4j_folder,
              "node.csv"
            ),
          col_types = readr::cols(.default = "c"),
          show_col_types = FALSE
        )

      edge <-
        readr::read_csv(
          file =
            file.path(
              neo4j_folder,
              "edge.csv"
            ),
          col_types = readr::cols(.default = "c"),
          show_col_types = FALSE
        )




      classification <-
        edge %>%
        dplyr::filter(
          rel_type == "subClassOf" # ,
          # rel_cat == 'asserted'
        ) %>%
        dplyr::transmute(
          concept_code_1 = source,
          relationship_id = "Is a",
          relationship_name = "subClassOf (NCIt)",
          rel_type,
          concept_code_2 = target,
          is_hierarchical = 1,
          defines_ancestry = 1
        )

      classification_b <-
        edge %>%
        dplyr::filter(
          rel_type == "subClassOf" # ,
          # rel_cat == 'asserted'
        ) %>%
        dplyr::transmute(
          concept_code_1 = target,
          relationship_id = "Subsumes",
          relationship_name = "Subsumes (CAI)",
          rel_type,
          concept_code_2 = source,
          is_hierarchical = 1,
          defines_ancestry = 1
        )

      relationships <-
        edge %>%
        dplyr::filter(
          rel_type != "subClassOf" # ,
          # rel_cat == 'asserted'
        ) %>%
        dplyr::transmute(
          concept_code_1 = source,
          relationship_id = rel_type,
          relationship_name = rel_type,
          rel_type,
          concept_code_2 = target,
          is_hierarchical = 0,
          defines_ancestry = 0
        )

      concept_relationship_stage <-
        dplyr::bind_rows(
          classification,
          classification_b,
          relationships
        ) %>%
        dplyr::left_join(
          node %>%
            select(
              concept_code_1 = code,
              concept_name_1 = Preferred_Name
            ),
          by = "concept_code_1"
        ) %>%
        dplyr::left_join(
          node %>%
            select(
              concept_code_2 = code,
              concept_name_2 = Preferred_Name
            ),
          by = "concept_code_2"
        ) %>%
        dplyr::distinct()



      root_class_codes <-
        classification %>%
        dplyr::filter(!(concept_code_2 %in% classification$concept_code_1)) %>%
        dplyr::distinct(concept_code_2) %>%
        unlist() %>%
        unname()

      leaf_concept_codes <-
        classification %>%
        dplyr::filter(!(concept_code_1 %in% classification$concept_code_2)) %>%
        dplyr::distinct(concept_code_1) %>%
        unlist() %>%
        unname()


      pre_domain_map <-
        concept_relationship_stage %>%
        mutate(
          concept_class_id_1 =
            dplyr::case_when(
              concept_code_1 %in% root_class_codes ~ "Root",
              concept_code_1 %in% leaf_concept_codes ~ "Leaf",
              TRUE ~ "SubClass"
            ),
          concept_class_id_2 =
            dplyr::case_when(
              concept_code_2 %in% root_class_codes ~ "Root",
              concept_code_2 %in% leaf_concept_codes ~ "Leaf",
              TRUE ~ "SubClass"
            )
        ) %>%
        dplyr::left_join(manual_domain_map, by = "rel_type")


      concepts_staged <-
        dplyr::bind_rows(
          pre_domain_map %>%
            select(
              concept_code = concept_code_1,
              concept_name = concept_name_1,
              concept_class_id = concept_class_id_1,
              domain_id = domain_id_1
            ),
          pre_domain_map %>%
            select(
              concept_code = concept_code_2,
              concept_name = concept_name_2,
              concept_class_id = concept_class_id_2,
              domain_id = domain_id_2
            )
        ) %>%
        mutate(domain_id = "Observation") %>%
        dplyr::distinct() %>%
        dplyr::left_join(
          tibble::tribble(
            ~`concept_class_id`, ~`standard_concept`,
            "Leaf", NA_character_,
            "Root", "C",
            "SubClass", NA_character_
          ),
          by = "concept_class_id"
        ) %>%
        dplyr::left_join(
          node %>%
            dplyr::distinct(
              code,
              Concept_Status
            ) %>%
            dplyr::transmute(
              concept_code = code,
              invalid_reason =
                ifelse(!is.na(Concept_Status),
                  "D",
                  Concept_Status
                ),
              valid_start_date =
                "1970-01-01",
              valid_end_date =
                ifelse(!is.na(Concept_Status),
                  "1970-01-01",
                  "2099-12-31"
                )
            ),
          by = "concept_code"
        ) %>%
        mutate(vocabulary_id = vocabulary_id) %>%
        select(all_of(c(
          "concept_name",
          "domain_id",
          "vocabulary_id",
          "concept_class_id",
          "standard_concept",
          "concept_code",
          "valid_start_date",
          "valid_end_date",
          "invalid_reason"
        ))) %>%
        dplyr::distinct()

      concept_relationship_stage2 <-
        concept_relationship_stage %>%
        dplyr::transmute(
          concept_code_1,
          concept_code_2,
          relationship_id,
          valid_start_date = "1970-01-01",
          valid_end_date   = "2099-12-31",
          invalid_reason   = NA_character_
        ) %>%
        dplyr::distinct() %>%
        select(all_of(
          c(
            "concept_code_1",
            "concept_code_2",
            "relationship_id",
            "valid_start_date",
            "valid_end_date",
            "invalid_reason"
          )
        ))

      relationship_stage <-
        concept_relationship_stage %>%
        dplyr::transmute(
          relationship_id,
          relationship_name,
          is_hierarchical,
          defines_ancestry,
          reverse_relationship_id = NA_character_,
          relationship_concept_id = NA_integer_
        ) %>%
        select(
          all_of(
            c(
              "relationship_id",
              "relationship_name",
              "is_hierarchical",
              "defines_ancestry",
              "reverse_relationship_id",
              "relationship_concept_id"
            )
          )
        ) %>%
        dplyr::distinct()


      vocabulary_stage <-
        tibble(
          vocabulary_id,
          vocabulary_name,
          vocabulary_reference = "https://meerapatelmd.github.io/setupNCI/",
          vocabulary_version,
          vocabulary_concept_id = NA_integer_
        )


      concept_class_stage <-
        concepts_staged %>%
        dplyr::transmute(concept_class_id,
          concept_class_name = concept_class_id,
          concept_class_concept_id = NA_integer_
        ) %>%
        dplyr::distinct()


      make_concept_id <-
        function(x) {
          2000000 + 1:length(x)
        }

      concepts_staged2 <-
        concepts_staged %>%
        mutate(
          concept_id =
            make_concept_id(concept_code)
        ) %>%
        select(
          concept_id,
          dplyr::everything()
        )

      concept_relationship_stage3 <-
        concept_relationship_stage2 %>%
        dplyr::left_join(concepts_staged2 %>%
          rename_all(function(x) sprintf("%s_1", x)),
        by = c("concept_code_1")
        ) %>%
        dplyr::left_join(concepts_staged2 %>%
          rename_all(function(x) sprintf("%s_2", x)),
        by = c("concept_code_2")
        ) %>%
        select(all_of(
          c(
            "concept_id_1",
            "concept_id_2",
            "relationship_id",
            "valid_start_date",
            "valid_end_date",
            "invalid_reason"
          )
        )) %>%
        dplyr::distinct()

      roots <-
        concepts_staged2 %>%
        dplyr::filter(concept_class_id == "Root") %>%
        select(concept_id) %>%
        unlist() %>%
        unname()

      roots_list <-
        vector(
          mode = "list",
          length = length(roots)
        ) %>%
        set_names(concepts_staged2 %>%
          dplyr::filter(concept_class_id == "Root") %>%
          select(concept_name) %>%
          unlist() %>%
          unname())

      tmp_folder <-
        file.path(
          omop_folder,
          "tmp"
        )

      tmp_folder <-
        makedirs(tmp_folder,
          verbose = FALSE
        )

      j <- 0
      total <- length(roots_list)
      cli::cli_h1("Processing each Root into {.emph Concept Ancestor} format...")

      for (root in roots) {
        jj <- j
        j <- j + 1

        tmp_root_file <-
          file.path(
            tmp_folder,
            xfun::with_ext(names(roots_list)[j], "csv")
          )

        cli::cli_text(
          "[{as.character(Sys.time())}] {.strong {names(roots_list)[j]}} {sprintf('%s/%s',j, total)} ({paste0(signif(((jj/total) * 100),
        digits = 2), '%')})"
        )


        if (!file.exists(tmp_root_file)) {
          output <- list()
          continue <- TRUE
          i <- 0

          while (continue == TRUE) {

            i <- i + 1

            if (i == 1) {
              output[[i]] <-
                concept_relationship_stage3 %>%
                dplyr::filter(
                  relationship_id == "Subsumes",
                  concept_id_1 == root
                ) %>%
                dplyr::transmute(
                  ancestor_concept_id_1 = root,
                  descendant_concept_id_1 = concept_id_2,
                  ancestor_concept_id_2 = concept_id_2
                ) %>%
                dplyr::distinct()
            } else {

              x <-
                output[[i - 1]] %>%
                select_at(vars(3)) %>%
                rename_all(function(x) str_replace_all(x, pattern = "^.*$", replacement = "concept_id_1")) %>%
                inner_join(
                  concept_relationship_stage3 %>%
                  dplyr::filter(relationship_id == "Subsumes"),
                  by = "concept_id_1") %>%
                dplyr::transmute(
                  ancestor_concept_id = concept_id_1,
                  descendant_concept_id = concept_id_2,
                  next_ancestor_concept_id = concept_id_2) %>%
                dplyr::distinct()

              if (nrow(x)==0) {

                continue <- FALSE

              } else {

                colnames(x) <-
                  c(
                    sprintf("ancestor_concept_id_%s", i),
                    sprintf("descendant_concept_id_%s", i),
                    sprintf("ancestor_concept_id_%s", i+1)
                  )

              output[[i]] <- x

              }
            }
          }


          quietly_left_join <-
            function(x,
                     y,
                     by = NULL,
                     copy = FALSE,
                     suffix = c(".x", ".y"),
                     ...,
                     keep = FALSE) {

              suppressMessages(
                dplyr::left_join(
                  x = x,
                  y = y,
                  by = by,
                  copy = copy,
                  suffix = suffix,
                  ...,
                  keep = keep
                )
              )


            }
          output2 <-
            output %>%
            reduce(quietly_left_join) %>%
            select(starts_with("ancestor_concept_id_")) %>%
            rename_all(str_remove_all, "ancestor_concept_id_") %>%
            dplyr::distinct() %>%
            rowid_to_column("rowid")


          paths_df <-
            output2 %>%
            pivot_longer(
              cols = !rowid,
              names_to = "levels_of_separation",
              values_to = "concept_id",
              values_drop_na = TRUE,
              names_transform = as.integer
            )


          max_level <- max(paths_df$levels_of_separation)

          tmp_ca <- list()

          for (level in 1:max_level) {

            tmp_ca[[level]] <-
            paths_df %>%
              group_by(rowid) %>%
              dplyr::filter(levels_of_separation == level) %>%
              ungroup() %>%
              transmute(rowid,
                        ancestor_concept_id = concept_id) %>%
              left_join(paths_df %>%
                          transmute(
                            rowid,
                            descendant_concept_id = concept_id,
                            levels_of_separation = levels_of_separation - level),
                        by = "rowid") %>%
              dplyr::filter(levels_of_separation >= 0)




          }

          tmp_ca2 <-
            bind_rows(tmp_ca) %>%
            select(-rowid) %>%
            distinct()


          tmp_ca3 <-
            tmp_ca2 %>%
            group_by(ancestor_concept_id,
                     descendant_concept_id) %>%
            summarize(min_levels_of_separation =
                        min(levels_of_separation),
                      max_levels_of_separation =
                        max(levels_of_separation),
                      .groups = "drop") %>%
            ungroup() %>%
            distinct()

          readr::write_csv(
            x = tmp_ca3,
            file = tmp_root_file,
            na = ""
          )

          cli::cli_text(
            "[{as.character(Sys.time())}] {.strong {names(roots_list)[j]}} {sprintf('%s/%s',j, total)} ({paste0(signif(((j/total) * 100),
        digits = 2), '%')})"
          )
        }
      }


      j <- 0
      roots_list2 <- list()
      for (root in roots) {
        jj <- j
        j <- j + 1

        tmp_root_file <-
          file.path(
            tmp_folder,
            xfun::with_ext(names(roots_list)[j], "csv")
          )

        roots_list2[[length(roots_list2)+1]] <-
        readr::read_csv(file = tmp_root_file,
                        show_col_types = FALSE)

      }

      concept_ancestor_stage <-
        dplyr::bind_rows(roots_list2) %>%
        dplyr::distinct()

      # Finding ancestor descendant pairs that
      # have more than 1 level associated to convert to min and maxes.
      # This data frame will likely be 0 rows, but it is
      # just a QA measure to ensure that there are no duplicates
      concept_ancestor_stage_b <-
        concept_ancestor_stage %>%
        count(
          ancestor_concept_id,
          descendant_concept_id
        ) %>%
        dplyr::filter(n > 1) %>% # Filter will likely result in 0 rows
        select(-n) %>%
        dplyr::left_join(concept_ancestor_stage,
          by = c("ancestor_concept_id", "descendant_concept_id")
        ) %>%
        pivot_longer(
          cols = c(
            min_levels_of_separation,
            max_levels_of_separation
          ),
          names_to = "level",
          values_to = "value"
        ) %>%
        select(-level) %>%
        group_by(
          ancestor_concept_id,
          descendant_concept_id
        ) %>%
        mutate(
          min_levels_of_separation =
            min(value, na.rm = TRUE),
          max_levels_of_separation =
            max(value, na.rm = TRUE)
        ) %>%
        ungroup() %>%
        select(-value) %>%
        dplyr::distinct()

      concept_ancestor_stage2 <-
        dplyr::left_join(
          concept_ancestor_stage,
          concept_ancestor_stage_b,
          by = c("ancestor_concept_id", "descendant_concept_id"),
          suffix = c("", "_updated")
        ) %>%
        mutate(
          min_levels_of_separation =
            coalesce(
              min_levels_of_separation_updated,
              min_levels_of_separation
            ),
          max_levels_of_separation =
            coalesce(
              max_levels_of_separation_updated,
              max_levels_of_separation
            )
        ) %>%
        select(-ends_with("_updated")) %>%
        dplyr::distinct()


      # Concept Synonym
      concept_synonym_stage <-
        node %>%
        select(
          code,
          Preferred_Name,
          FULL_SYN
        ) %>%
        separate_rows(FULL_SYN,
          sep = "[|]{1}"
        ) %>%
        mutate(
          lc_preferred_name =
            tolower(Preferred_Name)
        ) %>%
        mutate(
          lc_full_syn =
            tolower(FULL_SYN)
        ) %>%
        mutate(
          is_synonym =
            lc_preferred_name != lc_full_syn
        ) %>%
        dplyr::filter(is_synonym == TRUE) %>%
        dplyr::select(
          concept_code = code,
          concept_name = Preferred_Name,
          concept_synonym_name = FULL_SYN
        ) %>%
        dplyr::distinct()

      concept_synonym_stage2 <-
        concept_synonym_stage %>%
        dplyr::left_join(concepts_staged2,
          by = c("concept_code", "concept_name")
        ) %>%
        dplyr::transmute(
          concept_id,
          concept_synonym_name,
          language_concept_id = 4180186
        ) %>%
        dplyr::distinct()

      concept_synonym_stage2_b <-
        concepts_staged2 %>%
        dplyr::transmute(
          concept_id,
          concept_synonym_name = concept_name,
          language_concept_id = 4180186
        ) %>%
        dplyr::distinct()


      concept_synonym_stage3 <-
        dplyr::bind_rows(
          concept_synonym_stage2,
          concept_synonym_stage2_b) %>%
        dplyr::distinct() %>%
        arrange(concept_id)


      output_map <-
        list(
          CONCEPT = concepts_staged2,
          CONCEPT_SYNONYM = concept_synonym_stage3,
          CONCEPT_ANCESTOR = concept_ancestor_stage2,
          CONCEPT_RELATIONSHIP = concept_relationship_stage3,
          VOCABULARY = vocabulary_stage,
          RELATIONSHIP = relationship_stage,
          CONCEPT_CLASS = concept_class_stage
        ) %>%
        map(dplyr::distinct)


      for (i in seq_along(output_map)) {
        readr::write_csv(
          x = output_map[[i]],
          file = file.path(omop_folder, xfun::with_ext(names(output_map)[i], "csv")),
          na = "",
          quote = "all"
        )
      }

      cli::cli_inform("{cli::symbol$tick} OMOP Tables available at '{omop_folder}'")

      print(
        output_map %>%
          map(nrow) %>%
          tibble::enframe(
            name = "Table",
            value = "Rows"
          ) %>%
          mutate(
            Rows =
              unlist(Rows)
          )
      )
    }

    cli::cli_inform("{cli::symbol$tick} OMOP Tables already available at '{omop_folder}'. To rerun processing, delete 1 or all files and run function again.")

    cli::cli_inform("Use `setup_omop()` to load csvs into tables.")
  }
